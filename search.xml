<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[爬虫之破解极验验证（滑动验证码）]]></title>
    <url>%2F2018%2Fcrawler-geetest%2F</url>
    <content type="text"><![CDATA[概述说实话，本文代码主要是参考网上资料的。 极验验证的滑动验证码如下： 其实网上有许多破解极验验证的教程，主要分为两种，一种是手动分析各种请求，另一种是直接使用 Selenium 模拟浏览器。前者，破解过程繁琐，开发久，但是运行速度快；后者，开发快，但是运行很慢。。考虑到极验验证一直在更换各种请求 URL，参数等等（毕竟人家靠这个吃饭的啊），手动分析的方法时效性不强。所以，本文主要参考使用 Selenium 破解验证码的方法。 本文所使用的验证码例子如下： 极验验证-验证例子 破解过程如下： 访问该页面，点击 “滑动行为验证”，点击 “点击按钮进行验证”，使得滑动验证码出现。 获取验证码图像和带缺口的验证码图像 比对两张图像，获得滑块位移 模拟滑块运动，进行验证 本文代码使用的库如下： 123456789from PIL import Imagefrom selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.common.action_chains import ActionChainsfrom selenium.webdriver.support.ui import WebDriverWait as Waitfrom selenium.webdriver.support import expected_conditions as Expectimport new.anti.easing as easingimport timeimport cv2 1. 滑动验证码的出现这个比较简单啦，首先使用 Selenium 访问网页： 12345678910browser = webdriver.Chrome( executable_path="e:/chromedriver.exe", chrome_options=chrome_options)browser.get('http://www.geetest.com/type/')Wait(browser, 60).until( Expect.visibility_of_element_located((By.CLASS_NAME, "products-content")))time.sleep(1.2) 接着，点击 “滑动行为验证”： 12345slide_captcha = browser.find_element_by_xpath('//div[@class="products-content"]/ul/li[2]')slide_captcha.click()Wait(browser, 60).until( Expect.visibility_of_element_located((By.CLASS_NAME, "geetest_radar_tip_content"))) 然后，点击 “点击按钮进行验证”，就出现验证图片了： 123validate = browser.find_element_by_xpath('//span[@class="geetest_radar_tip_content"]')validate.click()time.sleep(0.5) 2. 获取验证码图像和带缺口的验证码图像这里用到 Selenium 的截图功能。Selenium 对元素截图会出错（原因我也不知，网上这样说的。。）。所以，我们要全屏截图，然后裁剪出验证码图像。在这里，我们要截取的元素，是重叠的。对于重叠的元素，我们先执行 JS 脚本，移除部分元素或者使得元素不可见，再截图。获取图像的函数如下： 123456789101112131415161718192021222324252627282930313233def get_pictures(browser): browser.execute_script(''' var x = document.getElementsByClassName("geetest_canvas_slice geetest_absolute"); x[0].style.display="none"; var y = document.getElementsByClassName("geetest_canvas_fullbg geetest_fade geetest_absolute"); y[0].style.display="none"; ''') time.sleep(0.8) # 带缺口的验证码图像的全屏截图 browser.save_screenshot('img1.jpg') # 裁剪验证码图像 crop_picture('img1.jpg') browser.execute_script(''' var x = document.getElementsByClassName("geetest_canvas_bg geetest_absolute"); x[0].style.display="none"; var y = document.getElementsByClassName("geetest_canvas_fullbg geetest_fade geetest_absolute"); y[0].style.display="block"; ''') time.sleep(0.8) # 不带缺口的验证码图像的全屏截图 browser.save_screenshot('img2.jpg') # 裁剪验证码图像 crop_picture('img2.jpg') # 使元素恢复成可见的 browser.execute_script(''' var x = document.getElementsByClassName("geetest_canvas_bg geetest_absolute"); x[0].style.display="block"; var y = document.getElementsByClassName("geetest_canvas_slice geetest_absolute"); y[0].style.display="block"; ''') 其中，裁剪函数如下： 123456789def crop_picture(filename): left = 830 top = 335 right = left + 260 bottom = top + 160 im = Image.open(filename) im = im.crop((left, top, right, bottom)) im.save(filename) 260 和 160 是验证码图像的宽度和高度。830 和 335 是根据屏幕的高和宽以及验证码图像的高和宽计算出来的。对于不同的浏览器和不同的显示器，这些数值可能不一样。合理的话，应该使用程序获取这些高度和宽度并计算的。但是我懒得写了。。 3. 比对两张图像，获得滑块位移这里，是对两张图片逐个像素进行匹配，如果某个像素点不匹配，该像素点就是滑块缺口的左上顶点。滑块的位移是水平方向的，初始滑块左上顶底横坐标大约是 12，所以 offset = j - 12。 但是实际上，我们截图的时候，截的验证码位置可能有误差，所以计算位移要考虑到误差的影响。在我这里，设置为 offset = j 1234567891011def get_offset(image1, image2, threshold): offset = -1 img1 = cv2.imread(image1) img2 = cv2.imread(image2) for j in range(260): for i in range(160): if not match(img1[i][j], img2[i][j], threshold): offset = j return offset return offset 匹配函数如下（注意 imread 函数读到的像素值是 uint8 类型，相减之后可能溢出，所以要转为 int）： 123456def match(i1, i2, t): p1 = [int(p) for p in i1] p2 = [int(p) for p in i2] if abs(p1[0] - p2[0]) &lt; t and abs(p1[1] - p2[1]) &lt; t and abs(p1[2] - p2[2]) &lt; t: return True return False 有个问题，就是，为什么我们要设置一个阈值呢？显而易见的原因是，图像之间可能存在少许误差嘛。不过，实际上，这个阈值设置得蛮大的（我设置为 50），这是因为，有些验证码图像加入了一些阴影干扰。 所以，像素之间差距小于阈值的，我们可以认为是跟原图像一样的，或者是阴影干扰项。 4. 模拟滑块运动，进行验证注意，得到位移后，不能进行简单的匀速拖拽，因为极验验证会识别是否是机器操作的。所以，拖拽的的过程要精心设计。这里，我啥都没干。。哈哈。直接 copy 了网上的代码，成功率还是蛮高的。验证的代码如下： 1234def do_crack(browser, offset): knob = browser.find_element_by_class_name("geetest_slider_button") fake_drag(browser, knob, offset) return 里面调用的函数，可以去参考资料 [2] 那里看 参考资料 [1] (极验滑动验证最新破解实践（18年1月底）)[https://zhuanlan.zhihu.com/p/31995134] [2] (使用 Python + Selenium 破解滑块验证码)[http://www.aneasystone.com/archives/2018/03/python-selenium-geetest-crack.html]]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>极限验证</tag>
        <tag>滑动验证码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql + Grafana 监控爬虫程序]]></title>
    <url>%2F2018%2Fcrawler-monitor%2F</url>
    <content type="text"><![CDATA[在使用爬虫爬取大量数据的时候，一般我们都会把程序挂在服务器上运行，然后就可以去干别的事情了。但是，我们还是有必要定时看一下程序运行情况的。虽然我们可以通过 log 信息来监控程序运行情况，但这往往不够直观。所以，今天我就讲讲如何使用 Mysql 和 Grafana 监控爬虫程序的运行状况，并可视化。 1. Grafana 简介 Grafana 是一个数据可视化工具，它并不收集数据，但是可以从数据源（例如 Graphite、Mysql、InfluxDB等）中获取数据并可视化。 2. 运行 GrafanaGrafana 安装教程可以去网上搜，不多说。这里说的是另一种替代方法：使用已经安装好 Grafana 的 Docker 镜像（效果也是一样的）。如果不了解 Docker 的话，可以看下教程 Docker — 从入门到实践 在这里，我们需要先安装好 Docker，并学会一些 Docker 基本命令，例如拉取镜像，容器的创建，容器的运行停止，镜像和容器的删除等等。 安装并运行 Docker 之后： 在 Docker hub 搜索一下包含 Grafana 的镜像，还是出现挺多个的。这里我选择了 kamon/grafana_graphite 在服务器上拉取镜像 1docker pull kamon/grafana_graphite 使用该镜像创建容器，并在后台运行123456789docker run \ -d \ -p 80:80 \ -p 81:81 \ -p 2003:2003 \ -p 8125:8125/udp\ -p 8126:8126\ --name=grafana_graphite \ kamon/grafana_graphite 到这里，我们就得到了一个已经安装了 Grafana 的容器，根本就不用我们手动安装了O(∩_∩)O 哈哈~ 在浏览器中打开 http://your_server_ip:80/，登录（初始用户名和密码都是 admin），我们就可以看到 Grafana 的控制台了，还是挺酷炫的！ 3. 编写爬虫程序并运行略。（在这里，要将爬取到的 item 储存起来，例如插入 mysql 数据库） 4. 编写监控的脚本并运行这里，我们要每隔一定时间查询爬取总量，并计算爬取速度。下面是一个例子：代码分为两部分，首先是在我们存放 item 的数据库建立两个表，每个表有两个字段，一个是查询时间，另一个是 item_total / item_min。123456789101112131415161718192021222324252627282930313233343536import pymysql as mdbimport time# 存放爬取数据的数据库（这里我把统计的数据，存入了爬取数据所在的数据库）DB_NAME = 'db_name'TABLE_NAME1 = 'item_per_min'TABLE_NAME2 = 'item_total'host = 'your_server_ip'user = 'your_user_name'passwd = 'your_pwd'# 爬取的 item 存放的表item_table = 'item_table'def create_table(): use_db_str = 'use ' + DB_NAME create_table_str1 = "CREATE TABLE if not exists " + TABLE_NAME1 + """( `time` datetime NOT NULL, `speed` int NOT NULL DEFAULT '0' ) ENGINE=InnoDB DEFAULT CHARSET=utf8;""" create_table_str2 = "CREATE TABLE if not exists " + TABLE_NAME2 + """( `time` datetime NOT NULL, `total` int NOT NULL DEFAULT '0' ) ENGINE=InnoDB DEFAULT CHARSET=utf8;""" # 数据库连接 conn = mdb.connect(host, user, passwd) cursor = conn.cursor() try: cursor.execute(use_db_str) cursor.execute(create_table_str1) cursor.execute(create_table_str2) conn.commit() except Exception as e: print(e) 代码第二部分是主函数，每隔一分钟查询 items 数，并计算爬取速度，将得到的数据储存起来： 12345678910111213141516171819202122232425if __name__ == '__main__': # 创建表 create_table() conn = mdb.connect(host, user, passwd, DB_NAME) cursor = conn.cursor() before_item = 0 while True: try: cursor.execute('SELECT count(*) FROM %s', item_table ) result = cursor.fetchone() current_item = result[0] print(current_item) # 过去一分钟爬取量 cursor.execute('insert into %s values (now(), %s)' % (TABLE_NAME1, current_item - before_item)) # 爬取总量 cursor.execute('insert into %s values (now(), %s)' % (TABLE_NAME2, current_item)) conn.commit() before_item = current_item except Exception as e: print(e) time.sleep(60) 监控脚本写完后，就可以挂在服务器后台运行了 5. Grafana 配置 配置数据源，这里命名为 monitor_crawler ​ 新建 Dashboard，然后点击 Graph 图标创建图，接着点击 Panel Title -&gt; Edit ​ 选择我们刚才创建的数据源 monitor_crawler ​ 按照 Grafana 提供的模板填写 sql 语句，这里查询了 item_per_min 表12345SELECT UNIX_TIMESTAMP(time) as time_sec, speed as value, &apos;items_min&apos; as metricFROM item_per_min （注意我们选择的是 Time series） 可以选择绘图模式，一般是选 Lines ​ 6. 成果展示 （其实 Grafana 还有很多很酷炫的设置，大家有兴趣可以去探索一下！） 总结在安装好各种环境之后，Mysql + Grafana 监控爬虫程序的步骤： 编写爬虫程序 编写监控脚本，将爬取速度和爬取总量定时存进 Mysql 数据库 Grafana 新建数据源，连接对应的 Mysql 数据库 创建新的 Dashboard，并在里面创建图表，图表数据源选择我们上一步新建的数据源]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>监控</tag>
        <tag>Mysql</tag>
        <tag>Grafana</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬虫获取 JS 动态数据（万方数据库文献下载）]]></title>
    <url>%2F2018%2Fcrawler-js-wanfang%2F</url>
    <content type="text"><![CDATA[今天讲讲用爬虫下载万方数据库文献。 这是我们要爬取的文献链接:http://www.wanfangdata.com.cn/details/detail.do?_type=perio&amp;id=zgtx201803009 右键那个下载按钮 -&gt; 检查，我们可以看见，按钮的点击事件是一个 js 函数 upload() 。 在网页源代码中，寻找这个 upload() 函数，发现它只在按钮处出现了一次。所以，这个函数应该是由 js 文件加载的。在网页源代码中，寻找 .js（搜索 js 文件），点击每一个 js 文件的链接，看看里面有没有 upload() 函数（这个方法貌似有点蠢，不知有没有更高效的方法）。最后在下图这个文件找到了： upload() 函数代码如下：12345678function onlineReading(page_cnt,id,language,source_db,title,isoa,type,resourceType)&#123; title=window.encodeURI(window.encodeURI(title)); var type = $("#document_type").val(); if(type == "standards")&#123; type="standard"; &#125; window.open("/search/onlineread.do?page_cnt="+page_cnt+"&amp;language="+language+"&amp;resourceType="+type+"&amp;source="+source_db+"&amp;resourceId="+id+"&amp;resourceTitle="+title+"&amp;isoa="+isoa+"&amp;type="+type);&#125; 可以看到，这个函数构造了一个 url， 并在一个新的标签页打开了这个 url。把参数填进去，构造出的 url 为 1http://www.wanfangdata.com.cn/search/downLoad.do?page_cnt=16&amp;language=eng&amp;resourceType=perio&amp;source=WF&amp;resourceId=zgtx201803009&amp;resourceTitle=Spectral Efficiency and Power Allocation for Mixed-ADC Massive MIMO System&amp;isoa=0&amp;type=perio 在浏览器中访问该 url ，发现我们看到的网址，并不是我们构造出的请求 url，说明应该是发生了重定向。 在一个新标签页中，按 F12 监听请求，并打开我们的请求 url 可以看到，我们构造的 url（也就是 downLoad.do? ），重定向到了 submitWeb.do? 。点击 submitWeb.do ，我们可以看到它重定向到了 transaction?，最后才重定向到 downloadliterature.do? 写爬虫时，我们要确保能够到达 downliterature.do?，后面才能下载文件。所以我们先写程序看看能不能提取出这个 downloadliterature.do? 的详细 url。 首先是用正则表达式提取 upload() 函数的参数，然后构造出请求 url，这里我懒得写了，直接 copy 一下： 1url = 'http://www.wanfangdata.com.cn/search/downLoad.do?page_cnt=16&amp;language=eng&amp;resourceType=perio&amp;source=WF&amp;resourceId=zgtx201803009&amp;resourceTitle=Spectral Efficiency and Power Allocation for Mixed-ADC Massive MIMO System&amp;isoa=0&amp;type=perio' 接着发起请求： 1234import requestsr = requests.get(url)print(r.status_code)print(r.url) 运行结果如下： 12200http://www.wanfangdata.com.cn/pay/downloadliterature.do?type=perio&amp;title=Spectral+Efficiency+and+Power+Allocation+for+Mixed-ADC+Massive+MIMO+System&amp;id=zgtx201803009&amp;isresult=false&amp;transaction=%7B%22id%22%3Anull%2C%22transferOutAccountsStatus%22%3Anull%2C%22transaction%22%3A%7B%22id%22%3A%221004368608312180736%22%2C%22status%22%3A1%2C%22createDateTime%22%3Anull%2C%22payDateTime%22%3A1528295111145%2C%22authToken%22%3A%22TGT-4001230-O5ZS0q7FIl2vYtxeLVbVr1LQu2Auh7D4pAjaGsfFg0EAc2oqNa-my.wanfangdata.com.cn%22%2C%22user%22%3A%7B%22accountType%22%3A%22Group%22%2C%22key%22%3A%22hnlgdx%22%7D%2C%22transferIn%22%3A%7B%22accountType%22%3A%22Income%22%2C%22key%22%3A%22PeriodicalFulltext%22%7D%2C%22transferOut%22%3A%7B%22GTimeLimit.hnlgdx%22%3A3.0%7D%2C%22turnover%22%3A3.0%2C%22productDetail%22%3A%22perio_zgtx201803009%22%2C%22productTitle%22%3Anull%2C%22userIP%22%3A%22183.6.159.220%22%2C%22organName%22%3Anull%2C%22memo%22%3Anull%2C%22webTransactionRequest%22%3Anull%2C%22signature%22%3A%22jFHSx941kWx4WEX3sb40p%2B36UW9cduGMuYGPL8yCRS3Gdg0BvqNSKwYJxVTKdMGTRec1pF1an8xM%5CnnIgvniLkT3%2FivH6myLpZ%2BlHCJdj3OxoKIlk3AEQq8%2B4QTDLnfJI5YKW554i2SIyruQpCVCxDBfMS%5CnIh%2Fe8%2BYtbwmuAXcUYwk%3D%22%2C%22delete%22%3Afalse%7D%2C%22isCache%22%3Afalse%7D 还是挺顺利的，一下子就得到了 downloadliterature.do? 的详细 url。这里解释一下：默认情况下，除了 requests.head() 方法，requests 会自动帮我们处理所有重定向。而 response.url 就会返回初始请求重定向后的最终网址。（差点忘了说了，我是用的学校网络，所以能免登陆下载。） 将得到的网址复制到浏览器中打开，会出现一个网页，再弹出下载对话框。这说明，downloadliterature.do? 并不是文件的最终下载链接，如果是文件的最终下载链接的话，就应该会直接弹出对话框。所以，我们的下一步就是找出真正的下载链接。 观察 downloadliterature.do? 网页： 这里有个点击下载的地方，通过 F12 以及查看网页源代码，我们可以看到文件的真正下载链接。接着，我们用正则表达式提取该链接，然后就可以用 requests 下载文件了。 最后，总结一下这一次寻找下载链接的思路： F12 检查 下载按钮 元素，发现，点击后触发的是一个 js 函数 upload()。 在网页源代码中找不到 upload() 的实现，转而在网页包含的 js 文件中找。 找到 upload() 后，根据其实现，构造请求 url。 在浏览器中打开请求 url，发现网页重定向了。用 requests 和 response 获取重定向后的 url 得到重定向的 url 后，打开，并提取其中包含的文件下载链接]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 爬虫中的多进程，多线程和协程（基础）]]></title>
    <url>%2F2018%2Fcrawler-multi-process-thread%2F</url>
    <content type="text"><![CDATA[这篇文章讲提高爬虫效率的三种方法： 多进程 多线程 协程 其实如果要详细讲的话，这三个方法还是挺复杂的，比如说进程间的通信问题，多线程的锁机制问题等。由于本人水平所限，这里就只讲讲这三者的基本用法吧。（虽然如此，掌握了这些基本用法，还是能够显著提升爬虫效率的。） 首先先总结下多进程、多线程和协程三者的特点： 多进程： 多线程： 协程： 下面是代码例子 多进程 多线程 协程]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>多进程</tag>
        <tag>多线程</tag>
        <tag>协程</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬虫获取 JS 动态数据（漫画图片下载）]]></title>
    <url>%2F2018%2Fcrawler-js-selenium%2F</url>
    <content type="text"><![CDATA[爬虫遇到 js 动态数据时，主要解决方法有两种： 使用一些库，例如 Selenium，来模拟浏览器环境抓取数据。但这样做对内存和 CPU 的消耗都比较大，爬虫效率低，应尽量避免。 手动分析 js 请求 下面我选了一个漫画网站作为小例子，讲一下第二个方法。 https://manhua.sfacg.com/mh/YSJ/4519/ 我们的目的是获取漫画图片 url，然后下载下来。 判断待爬数据是否 js 动态加载的用 chrome 打开该网页，右键漫画图片 -&gt; 检查 我们可以看到图片的 url 就在里面。可以右键此处（蓝色部分）-&gt; copy -&gt; copy xpath 获得图片对应的 xpath，然后可以使用 requests 和 xpath 获取图片 url。当然最后还是失败了。因为这里的图片是 js 动态加载出来的。 获取跟待爬数据有关的 js 代码信息我们可以查看网页源代码，Ctrl+F 定位图片 id “curPic”： 可以看到，里面根本没有图片的 url，图片是 js 加载的。阅读里面的 js 代码，我们可以知道图片 url 是由下面这行代码决定的： 1pic2.src = hosts[getHost()] + picAy[curIndex] 在源码中寻找 hosts 和 picAy，发现它们只在这里出现过。这说明这两个数组可能是由 js 代码加载的。 寻找跟待爬数据有关的 js 请求回到漫画那个页面，我们打开 Chrome 的 F12，点击 network，勾选 js，刷新网页，查看相关 js 请求对应的 preview，看看哪些包含 hosts 和 picAy： 额，这进展还是出乎意料的顺利，第一个 js 就有我们想要寻找的内容了。我们可以看到，这一话漫画的所有图片都在这个 js 请求的响应内容里了。由此图可知，我们进入某一话漫画的第一页时，就有一份 js 代码请求了这一话漫画所有页的图片 url。那么，我们在写程序的时候，该如何得到这份 js 的文件名？ 观察其他漫画的情况，我们可以发现，虽然这份 js 代码的命名没啥规律，不过在网页源代码中，它一般是处于第一个 js 的位置。 总结至此，总结一下如何下载该网站漫画： 获取一话漫画的第一页 url 获取该 url 响应的 html 在 html 中寻找第一个 js 代码文件名 获取该 js 的响应内容，从中提取所有图片 url 总结一下该例子中获取 js 动态数据的思路： 判断是不是 js 加载的数据 如果是 js 加载的，查看网页源代码中待下载数据附近的 js 代码，获取关键信息（比如一些变量名） 回到待爬网页那里，按 F12（我用的 Chrome），点击 network，勾选 js，刷新网页，获取 js 请求 逐个查看每个请求的 preview，看有没有跟待爬取内容相关的信息。]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring+SpringMVC+MyBatis 配置总结]]></title>
    <url>%2F2018%2Fconfigure-ssm%2F</url>
    <content type="text"><![CDATA[这篇文章主要讲 MyBatis 的配置， Spring MVC 的配置，以及 SSM 整合配置。此文章仅涉及常用的基本设置。 本文章是基于我个人的理解和知识水平，通过查阅资料所写下的笔记总结，主要是方便自己记住常用的基本配置。更详细的知识点请参见文末的参考资料。 MyBatis 配置在工程的 src 文件夹下创建 MyBatis 配置文件SqlMapConfig.xml 一个简单例子如下： 12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//MyBatis.org//DTD Config 3.0//EN" "http://MyBatis.org/dtd/MyBatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 和spring整合后 environments配置将废除--&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;!-- 使用jdbc事务管理--&gt; &lt;transactionManager type="JDBC" /&gt; &lt;!-- 数据库连接池,由MyBatis管理--&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver" /&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/databaseName?characterEncoding=utf-8" /&gt; &lt;property name="username" value="root" /&gt; &lt;property name="password" value="admin" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 加载映射文件--&gt; &lt;mappers&gt; &lt;mapper resource="mapper/Student.xml"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 各常用便签配置顺序大致如下： configuration properties settings typeAliases environments environment transactionManager dataSource mappers propertiesproperties 包含可外部化的，可替换的属性，可以在典型的Java属性文件实例中配置，或通过 properties 元素的子元素传入。例如： 1234&lt;properties resource=&quot;org/MyBatis/example/config.properties&quot;&gt; &lt;property name=&quot;username&quot; value=&quot;dev_user&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;F2Fa3!33TYyg&quot;/&gt;&lt;/properties&gt; 然后这些属性可以在整个SqlMapConfig.xml 配置文件中使用。 注意加载属性的顺序：先读取 properties 元素的子元素定义的属性。然后读取 properties 元素中 resource 加载的属性，它会覆盖已读取的同名属性。 （一般建议不要在 properties 元素体内定义属性，只将属性定义在 properties 文件中。） 一个常见的例子是，在 db.properties 中配置 dataSource 参数： 1234jdbc.driver = com.mysql.jdbc.Driverjdbc.url = jdbc:mysql://localhost:3306/databaseName?characterEncoding=utf-8jdbc.username = rootjdbc.password = admin 同时改动 SqlMapConfig.xml 文件 12345678910111213141516&lt;properties resource="db.properties"&gt; &lt;/properties&gt;&lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;!-- 使用jdbc事务管理--&gt; &lt;transactionManager type="JDBC" /&gt; &lt;!-- 数据库连接池,由MyBatis管理--&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;jdbc.driver&#125;" /&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt; 通过这种方式配置，可以方便对数据库参数的统一管理 settingssettings 可以配置 MyBatis 在运行时的行为方式，比如：开启延迟加载（默认没有开启），开启二级缓存（默认没有开启）等。 123456789&lt;settings&gt; &lt;!-- 打开延迟加载 的开关 --&gt; &lt;setting name="lazyLoadingEnabled" value="true"/&gt; &lt;!-- 将积极加载改为消极加载即按需要加载 --&gt; &lt;setting name="aggressiveLazyLoading" value="false"/&gt; &lt;!-- 开启二级缓存 --&gt; &lt;setting name="cacheEnabled" value="true"/&gt;&lt;/settings&gt; 注意：开启二级缓存除了在 settings 中设置，还需要在别的地方设置，这里不多说 typeAliasestypeAliases，指的是类型别名 。 我们在mapper.xml 中给 resultType 或者 parameterType 中指定映射 java 类型时，需要输入类型的全路径。例如： 123&lt;select id="findAuthorById" parameterType="int" resultType="domain.blog.Author"&gt; SELECT * FROM author WHERE id=#&#123;value&#125;&lt;/select&gt; 我们可以使用类型别名，方便开发。在 SqlMapConfig.xml 中配置： 12345&lt;typeAliases&gt; &lt;typeAlias alias="Author" type="domain.blog.Author"/&gt; &lt;typeAlias alias="Blog" type="domain.blog.Blog"/&gt; &lt;typeAlias alias="Comment" type="domain.blog.Comment"/&gt;&lt;/typeAliases&gt; 这样，我们在mapper.xml 中就可以使用类型别名： 123&lt;select id="findAuthorById" parameterType="int" resultType="Author"&gt; SELECT * FROM author WHERE id=#&#123;value&#125;&lt;/select&gt; 我们也可以指定包名，MyBatis 会自动扫描包中的 java beans。 123&lt;typeAliases&gt; &lt;package name="domain.blog"/&gt;&lt;/typeAliases&gt; 这样，domian.blog 包中的所有 java bean 的类型别名默认就是类名（首字母大小写都可以）。如果某个类中有@Alias 注解，则类型别名是注解中的值。如： 1234@Alias("myAuthor")public class Author &#123; ...&#125; Mybatis 中有许多内置的针对常用 java 类的类型别名，常见的有： 别名 类 _long long _short short _int int _double double _float float _boolean boolean string String byte Byte long Long short Short int Integer double Double float Float boolean Boolean date Date map Map hashmap HashMap list List arraylist ArrayList environmentsenvironments 内可配置事务管理和数据库连接，开头已经给出了一个例子，不多说。 mappersmappers可配置从哪里加载映射文件，有几种配置方法： (1) 通过 resource 加载映射文件 1234&lt;mappers&gt; &lt;mapper resource="mapper/AuthorMapper.xml" /&gt; &lt;mapper resource="mapper/BlogMapper.xml" /&gt;&lt;/mappers&gt; (2) 通过 mapper 接口加载映射文件 12345678&lt;mappers&gt; &lt;!-- 通过mapper接口加载单个 映射文件 遵循一些规范：需要将mapper接口类名和mapper.xml映射文件名称保持一致，且在一个目录中 上边规范的前提是：使用的是mapper代理方法 --&gt; &lt;mapper class="com.anye137.AuthorMapper"/&gt; &lt;mapper class="com.anye137.BlogMapper"/&gt;&lt;/mappers&gt; (3) 指定 mapper 接口的包名（推荐） 12345678&lt;mappers&gt; &lt;!-- 批量加载mapper 指定mapper接口的包名，mybatis自动扫描包下边所有mapper接口进行加载 遵循一些规范：需要将mapper接口类名和mapper.xml映射文件名称保持一致，且在一个目录 中 上边规范的前提是：使用的是mapper代理方法 --&gt; &lt;package name="com.anye137.mapper"/&gt;&lt;/mappers&gt; 总结下面是一个配置例子。以后要配置的时候从这里粘贴，再进行小小的改动就行了，哈哈哈。 db.properties 1234&lt;properties resource=&quot;org/MyBatis/example/config.properties&quot;&gt; &lt;property name=&quot;username&quot; value=&quot;dev_user&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;F2Fa3!33TYyg&quot;/&gt;&lt;/properties&gt; SqlMapConfig 123456789101112131415161718192021222324252627282930&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//MyBatis.org//DTD Config 3.0//EN" "http://MyBatis.org/dtd/MyBatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;properties resource="db.properties"&gt; &lt;/properties&gt; &lt;!-- 和spring整合后 environments配置将废除--&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;!-- 使用jdbc事务管理--&gt; &lt;transactionManager type="JDBC" /&gt; &lt;!-- 数据库连接池,由MyBatis管理--&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;jdbc.driver&#125;" /&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 加载映射文件--&gt; &lt;mappers&gt; &lt;package name="com.anye137.mapper"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; Spring MVC 配置web.xml 123456789101112131415161718192021&lt;web-app id="WebApp_ID" version="2.4" xmlns="http://java.sun.com/xml/ns/j2ee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"&gt; &lt;display-name&gt;Spring MVC Application&lt;/display-name&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt; org.springframework.web.servlet.DispatcherServlet &lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; web.xml 文件放在应用程序的 WebContent/WEB-INF 目录下。在初始化 DispatcherServlet 时，Spring MVC 将尝试加载位于该应用程序的 WebContent/WEB-INF 目录中的文件名为 [servlet-name]-servlet.xml 的文件。在上面的例子中，文件名将是springmvc-servlet.xml。 接下来，url-pattern标签表明哪些 URLs 将被DispatcherServlet 处理。这里所有以 .jsp 结束的 HTTP 请求将由该DispatcherServlet处理。 如果不想使用默认文件名和默认位置，可以通过在 web.xml 文件中添加 servlet 监听器 ContextLoaderListener 自定义该文件的名称和位置，如下所示： 123456789101112131415161718192021&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- spring mvc的配置文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springMVC.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; springMVC.xml 文件如下： 123456789101112131415161718192021222324&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt; &lt;!-- 使用注解的处理器映射器和适配器 --&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; &lt;!-- 指定Controller的包--&gt; &lt;context:component-scan base-package="com.anye137.Controller" /&gt; &lt;!-- 视图解析器--&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;!-- 配置jsp路径的前缀--&gt; &lt;property name="prefix" value="/WEB-INF/jsp/" /&gt; &lt;!-- 配置jsp路径的后缀--&gt; &lt;property name="suffix" value=".jsp" /&gt; &lt;/bean&gt; &lt;/beans&gt; (1) mvc:annotation-driven 标签默认加载很多的参数绑定方法，包括了默认使用注解的处理器映射器和适配器。 (2) context 标签用于启用 Spring MVC 注释扫描功能，该功能允许使用注释，如 @Controller 和 @RequestMapping 等等。 (3) 上面的视图解析器中配置了 jsp 路径的前后缀。比如说： 12modelAndView.setViewName("hello");return modelAndView; 这样，一个名称为 hello 的视图将发送给位于 /WEB-INF/jsp/hello.jsp 中实现的视图。 Spring+Spring MVC+MyBatis 整合配置终于到重头戏部分了！ 其实以后应该不怎么单独使用 MyBatis 或者 Spring MVC，如果要用框架的话一般会整合几个框架，例如 SSM。 所以下面讲的配置就是本文的重点了。以后写 SSM 项目的话我就可以直接在这里 copy 配置了。嘻嘻！ 这里分三步来整合，即 整合 dao 层（这里是mapper）， 整合 service 层 和 整合 Spring MVC。整合完三部分后，再配置web.xml 整合 dao 层Spring 和 MyBatis 整合，通过 Spring 管理 mapper 接口 src 文件夹下创建数据库配置文件 db.properties 1234jdbc.driver = com.mysql.jdbc.Driverjdbc.url = jdbc:mysql://localhost:3306/databaseName?characterEncoding=utf-8jdbc.username = rootjdbc.password = admin src 文件夹下创建 mybatis 文件夹，在里面创建 Mybatis 配置文件SqlMapConfig.xml 1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 全局setting配置，根据需要添加 --&gt; &lt;settings&gt; &lt;!-- 获取数据库自增主键值 --&gt; &lt;setting name="useGeneratedKeys" value="true" /&gt; &lt;/settings&gt; &lt;!-- 配置别名 --&gt; &lt;typeAliases&gt; &lt;!-- 批量扫描别名 --&gt; &lt;package name="com.anye137.pojo"&gt; &lt;/typeAliases&gt; &lt;!-- 配置environments，这里不需要配置。由Spring管理配置 --&gt; &lt;!-- 配置mapper 由于使用spring和mybatis的整合包进行mapper扫描，这里不需要配置了。 必须遵循：mapper.xml和mapper.java文件同名且在一个目录 --&gt;&lt;/configuration&gt; 注意，这里跟上面提到的SqlMapConfig.xml 配置有所不同。这里没有配置 数据源和 mapper。这两个由applicationContext-dao.xml配置。此外，该文件还配置了 SqlSessionFactory。 src 文件夹下创建 spring 文件夹，在里面创建 applicationContext-dao.xml 1234567891011121314151617181920212223242526272829303132333435&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd"&gt; &lt;!-- 加载db.properties文件中的内容 --&gt; &lt;context:property-placeholder location="classpath:db.properties" /&gt; &lt;!-- 配置数据源 ，这里使用dbcp --&gt; &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driver&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;property name="maxActive" value="30" /&gt; &lt;property name="maxIdle" value="5" /&gt; &lt;/bean&gt; &lt;!-- sqlSessionFactory --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;property name="configLocation" value="classpath:mybatis/SqlMapConfig.xml" /&gt; &lt;/bean&gt; &lt;!-- mapper扫描器 --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;!-- 扫描包路径，如果需要扫描多个包，中间使用半角逗号隔开 --&gt; &lt;property name="basePackage" value="com.anye137.mapper"/&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory" /&gt; &lt;/bean&gt;&lt;/beans&gt; 整合 service 层通过 Spring 管理 service 接口，以及实现事务控制 src/spring 文件夹内创建 applicationContext-service.xml 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;!-- 扫描service包下所有使用注解的类型 --&gt; &lt;context:component-scan base-package="com.soecode.lyf.service" /&gt; &lt;!-- 配置事务管理器 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;!-- 数据源dataSource在applicationContext-dao.xml中配置了 --&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; &lt;!-- 配置基于注解的声明式事务 --&gt; &lt;tx:annotation-driven transaction-manager="transactionManager" /&gt; &lt;/beans&gt; 整合 Spring MVC这一步跟上面讲到的 Spring MVC 配置类似。 src/spring 文件夹内创建springMVC.xml 123456789101112131415161718192021222324&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt; &lt;!-- 使用注解的处理器映射器和适配器 --&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; &lt;!-- 指定Controller的包--&gt; &lt;context:component-scan base-package="com.anye137.Controller" /&gt; &lt;!-- 视图解析器--&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;!-- 配置jsp路径的前缀--&gt; &lt;property name="prefix" value="/WEB-INF/jsp/" /&gt; &lt;!-- 配置jsp路径的后缀--&gt; &lt;property name="suffix" value=".jsp" /&gt; &lt;/bean&gt; &lt;/beans&gt; 配置 web.xmlweb.xml 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" id="WebApp_ID" version="3.0"&gt; &lt;!-- 加载配置文件 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/applicationContext-*.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- Spring MVC 配置文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/springMVC.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;/web-app&gt; 至此，SSM 整合大功告成！ 注意所有配置文件的路径，不要搞错了。 参考资料(1) MyBatis学习笔记(5)-配置文件(2) MyBatis Configuration xml(3) Spring MVC 中文文档(4) Spring MVC 学习笔记]]></content>
      <categories>
        <category>java</category>
        <category>java web</category>
      </categories>
      <tags>
        <tag>java web</tag>
        <tag>Spring</tag>
        <tag>Spring MVC</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单商品管理系统（下）]]></title>
    <url>%2F2018%2Fjava-web-product-management-2%2F</url>
    <content type="text"><![CDATA[上一篇文章实现了对商品信息的增删查改部分，这篇文章讲用户的登录注册部分。其中部分实现原理跟上文类似。 项目实现数据库建表及插入数据12345678create table user( id int auto_increment, name char(30), pwd char(30), primary key(id));insert into user (name,pwd) values ('暗夜','137');insert into user (name,pwd) values ('zero','000'); domain 包新建 User.java，代码如下（省略了 setter 和 getter 方法）： 1234567package domain;public class User &#123; private int id; private String name; private String pwd;&#125; dao 包新建 UserDAO 类 ，里面有三个方法，一个用于获取数据库连接，一个是根据用户名和密码查找用户（用于登录判断），一个是增加用户（用于注册）。 注意：上一篇文章 dao 中新增商品的函数返回的是 int 值。1代表增加成功，0代表失败。增加商品后随即跳转到listProduct.jsp 。但是，注册（调用addUser() ）成功后，跳转到listProduct.jsp 之前，要将 user 信息设置到 session 的属性中。所以addUser() 方法返回的是 User 对象，对象不为 null 则表示增加成功。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package dao;import domain.User;import java.sql.DriverManager;import java.sql.*;public class UserDAO &#123; //封装获取数据库连接的方法 public Connection getConnection() throws SQLException&#123; //代码略，详细代码可见文末的 GitHub 链接 &#125; //增加用户，并返回新增的用户对象 public User addUser(User u)&#123; Connection conn = null; PreparedStatement preStmt = null; ResultSet rs = null; User user = null; String sql = "insert into user (name,pwd) values (?,?)"; try&#123; conn = getConnection(); //第二个参数表明支持获取新增数据的id preStmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS); preStmt.setString(1, u.getName()); preStmt.setString(2, u.getPwd()); int result = preStmt.executeUpdate(); if(result==1)&#123; rs = preStmt.getGeneratedKeys(); if(rs.next())&#123; int id = rs.getInt(1); user = new User(); user.setId(id); user.setName(u.getName()); user.setPwd(u.getPwd()); &#125; &#125; if(conn!=null) conn.close(); if(preStmt!=null) conn.close(); &#125;catch(SQLException e)&#123; e.printStackTrace(); &#125; return user; &#125; //根据用户名和密码查找用户 public User findUser(String name,String pwd)&#123; //代码略，详细代码可见文末的 GitHub 链接 &#125;&#125; service 包service 包调用 dao 包中的方法，来实现业务逻辑。本项目比较简单，所以这里只是简单地调用 UserDAO 来实现登录和注册功能。 新建 UserService 类： 1234567891011121314151617package service;import dao.UserDAO;import domain.User;public class UserService &#123; private UserDAO udao = new UserDAO(); //新增用户 public User addUser(User u)&#123; return udao.addUser(u); &#125; //根据用户名和密码查找用户 public User findUser(String name,String pwd)&#123; return udao.findUser(name, pwd); &#125;&#125; Servlet 包为了方便，我就把登录界面和注册界面写到了同一个文件loginOrRegister.jsp ，里面包含一个登录用的表单，一个注册用的表单，详细代码可见文末的 Github 链接。 此外，该文件还有一个用于弹出错误对话框的代码片段： 1234567&lt;c:if test="$&#123; not empty error&#125;"&gt; &lt;script type="text/javascript" language="javascript"&gt; alert("$&#123; error &#125;"); &lt;/script&gt; &lt;%session.removeAttribute("error"); %&gt;&lt;/c:if&gt; 直接打开登录注册界面时，error 属性是空的（即 null），所以不会弹出错误对话框。 登录或者注册时，对应的 servlet 会判断操作是否失败，如果失败了，则在 session 中设置 error 属性，并重定向到 登录注册界面，此时 error 属性非空，就会弹出错误对话框。关闭对话框时，会移除 session 中的 error 属性。 LoginServlet 类 主要代码： 12345678910111213141516171819202122232425262728293031323334353637package servlet;import domain.User;import service.UserService;@WebServlet("/loginServlet")public class LoginServlet extends HttpServlet&#123; private UserService us = new UserService(); public void service(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException&#123; //设置编码 request.setCharacterEncoding("utf-8"); String name = request.getParameter("name"); String pwd = request.getParameter("pwd"); //根据用户名和密码查找用户 User u = us.findUser(name, pwd); //如果找不到 if(u==null)&#123; //在request中设置error属性，然后跳转到登录界面，登录界面根据error属性弹出登录失败对话框 request.getSession().setAttribute("error", "用户名或者密码错误"); response.sendRedirect("login.jsp"); &#125; //如果找到对应用户 else&#123; //设置session的user属性，并跳转到展示商品的界面，商品界面根据user属性会展示登录用户的信息 request.getSession().setAttribute("user", u); response.sendRedirect("listProduct"); &#125; &#125;&#125; RegisterServlet 类 主要代码： 12345678910111213141516171819202122232425262728293031323334353637package servlet;import domain.User;import service.UserService;@WebServlet("/registerServlet")public class registerServlet extends HttpServlet&#123; private UserService us = new UserService(); public void service(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException&#123; //设置编码 request.setCharacterEncoding("utf-8"); String name = request.getParameter("name"); String pwd = request.getParameter("pwd"); User u = new User(); u.setName(name); u.setPwd(pwd); //注册 u = us.addUser(u); //如果注册成功 if(u!=null)&#123; request.getSession().setAttribute("user", u); response.sendRedirect("listProduct"); &#125; else&#123; request.getSession().setAttribute("error", "注册失败"); response.sendRedirect("login.jsp"); &#125; &#125; &#125; 此外，如果登录成功或者注册成功，会设置 session 的 user 属性，然后跳转到 listProduct.jsp 。在listProduct.jsp 中新增用于显示用户信息的代码片段： 1234567&lt;div align='center'&gt; &lt;c:if test="$&#123;not empty user&#125;"&gt; 你好，$&#123;user.name&#125; &amp;nbsp; &lt;/c:if&gt; &lt;a href="logout"&gt;注销&lt;/a&gt; &lt;/div&gt; 上面代码中还有注销的链接，对应于 LogoutServlet.java ： 12345678910@WebServlet("/logout")public class LogoutServlet extends HttpServlet&#123; public void service(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException&#123; request.getSession().removeAttribute("user"); response.sendRedirect("loginOrRegister.jsp"); &#125;&#125; 现在用户的登录注册功能已经实现了。 输入http://localhost:8080/Management/loginOrRegister.jsp 即可登录或注册 至此，一个简单商品管理系统已实现完毕。 总结这个项目虽小，可是还有一些不足，如下： (1) 提交表单信息时，没有先判断是否输入为空 (2) 提交表单信息后，没有在 servlet 中判断提交信息的合法性，例如填价格时要判断填的是否数字 (3) 没有禁止相同的商品名和相同的用户名。如果要禁止的话，要新增一些用于判断的代码。 哈哈，这些功能有空慢慢补上吧。 本文章完整代码见 Github。 参考资料(1) JSP 弹出对话框的方式总结 from CSDN]]></content>
      <categories>
        <category>java</category>
        <category>java web</category>
      </categories>
      <tags>
        <tag>java web</tag>
        <tag>商品管理系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单商品管理系统（上）]]></title>
    <url>%2F2018%2Fjava-web-product-management-1%2F</url>
    <content type="text"><![CDATA[概述本文讲的是，使用 servlet+jsp+jdbc+mysql 实现一个简单的商品管理系统，不使用任何框架，从而加深自己对 java web 基础知识的理解。 实现的主要功能有： (1) 对商品信息的增删查改 (2) 用户的登录注册功能 本文主要讲商品信息的增删查改，下一篇文章讲用户的登录注册。 项目结构项目目录如下： 本项目使用 MVC 设计模式（Mode-View-Controller） ： Controller：负责转发请求，对请求进行处理。本项目使用 servlet 来实现。 View：负责界面展示。本项目使用 jsp 实现。（本项目 jsp 文件位于 WebContent 目录下） Model： 负责操作数据库。本项目 model 包含 domain 包和 dao 包。 此外，项目中还有一个 service 包，负责实现业务逻辑。包与包之间的关系是： (1) domain 中的一些类映射数据库中的表，(2) dao 包使用 jdbc 操作数据库，并将结果映射到 domain 中的java bean类，(3) service 包调用 dao 包的方法来实现业务逻辑，(4) servlet 包调用 service 包的方法来处理或者转发请求，以及实现页面的跳转。 项目具体文件如下： 项目实现数据库建表及插入数据新建数据库 management，设置编码为 utf-8 1create database management character set utf8; 创建表 product 并插入数据 12345678910111213141516171819use management;drop table if exists product;create table product( id int auto_increment, name char(30), price float, primary key(id));insert into product (name,price) values ('飞机',1000.0);insert into product (name,price) values ('大炮',500.5);insert into product (name,price) values ('子弹',32.0);insert into product (name,price) values ('方舟',700.0);insert into product (name,price) values ('软件',980.0);insert into product (name,price) values ('飞船',60.0);insert into product (name,price) values ('神威',80.6);insert into product (name,price) values ('筷子',78.5);insert into product (name,price) values ('篮球',65.4);insert into product (name,price) values ('平板',54.7); domain 包domain 包下新建 Product 类。该类对应于 product 表，类中的三个属性也对应于 product 表的列名。 1234567891011121314151617181920212223242526package domain;public class Product &#123; private int id; private String name; private float price; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public float getPrice() &#123; return price; &#125; public void setPrice(float price) &#123; this.price = price; &#125;&#125; dao 包DAO（数据库操作对象，Database Access Object）是 JDBC 下常用的模式，保存数据时它获取 java bean 的属性值，插入 sql 语句中，并保存到数据库中；读取数据时将数据从数据库中读取出来，并将值设置到 java bean 的属性中。 本项目与数据库直接相关的操作都放在 dao 包中。在此包下新建 ProductDAO 类，类中有对商品信息进行增删查改的各个方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171package dao;import domain.Product;import java.sql.*;import java.util.ArrayList;import java.util.List;public class ProductDAO &#123; //对数据库连接进行封装 public Connection getConnection() throws SQLException&#123; DriverManager.registerDriver(new com.mysql.jdbc.Driver()); Connection conn = DriverManager.getConnection( "jdbc:mysql://localhost:3306/management?characterEncoding=utf-8", "root","admin"); return conn; &#125; //增加商品 public int addProduct(Product p)&#123; Connection conn = null; PreparedStatement preStmt = null; int result=0; String sql = "insert into product (name,price) values (?,?)"; try&#123; //获取数据库连接 conn = getConnection(); preStmt = conn.prepareStatement(sql); preStmt.setString(1, p.getName()); preStmt.setFloat(2, p.getPrice()); result = preStmt.executeUpdate(); if(preStmt!=null) preStmt.close(); if(conn!=null) conn.close(); &#125;catch(SQLException e)&#123; e.printStackTrace(); &#125; //增加成功则返回1，失败则是0 return result; &#125; //删除商品 public int deleteProduct(int id)&#123; Connection conn = null; PreparedStatement preStmt = null; int result=0; String sql = "delete from product where id=?"; try&#123; //获取数据库连接 conn = getConnection(); preStmt = conn.prepareStatement(sql); preStmt.setInt(1, id); result = preStmt.executeUpdate(); if(preStmt!=null) preStmt.close(); if(conn!=null) conn.close(); &#125;catch(SQLException e)&#123; e.printStackTrace(); &#125; //删除成功则返回1，失败则是0 return result; &#125; //更新商品 public int updateProduct(Product p)&#123; Connection conn = null; PreparedStatement preStmt = null; int result=0; String sql = "update product set name=?,price=? where id=?"; try&#123; //获取数据库连接 conn = getConnection(); preStmt = conn.prepareStatement(sql); preStmt.setString(1, p.getName()); preStmt.setFloat(2, p.getPrice()); preStmt.setInt(3, p.getId()); result = preStmt.executeUpdate(); if(preStmt!=null) preStmt.close(); if(conn!=null) conn.close(); &#125;catch(SQLException e)&#123; e.printStackTrace(); &#125; //更新成功则返回1，失败则是0 return result; &#125; //列出所有商品 public List&lt;Product&gt; listProduct()&#123; Connection conn = null; PreparedStatement preStmt = null; ResultSet rs = null; String sql = "select * from product"; List&lt;Product&gt; plist=new ArrayList&lt;&gt;(); try&#123; //获取数据库连接 conn = getConnection(); preStmt = conn.prepareStatement(sql); rs = preStmt.executeQuery(); while(rs.next())&#123; Product p=new Product(); p.setId(rs.getInt("id")); p.setName(rs.getString("name")); p.setPrice(rs.getFloat("price")); plist.add(p); &#125; if(preStmt!=null) preStmt.close(); if(conn!=null) conn.close(); &#125;catch(SQLException e)&#123; e.printStackTrace(); &#125; //返回 product list return plist; &#125; //根据id找到商品，如果找不到则返回null public Product findProductById(int id)&#123; Connection conn = null; PreparedStatement preStmt = null; ResultSet rs = null; String sql = "select * from product where id=?"; Product p=new Product(); try&#123; //获取数据库连接 conn = getConnection(); preStmt = conn.prepareStatement(sql); preStmt.setInt(1, id); rs = preStmt.executeQuery(); if(rs.next())&#123; p.setId(rs.getInt("id")); p.setName(rs.getString("name")); p.setPrice(rs.getFloat("price")); &#125; if(preStmt!=null) preStmt.close(); if(conn!=null) conn.close(); &#125;catch(SQLException e)&#123; e.printStackTrace(); &#125; return p; &#125;&#125; service 包service 包主要负责业务逻辑的实现，本项目比较简单，只实现商品信息的增删查改，所以只是简单调用了 dao 包中的方法。新建 ProductService 类。 1234567891011121314151617181920212223242526272829package service;import domain.Product;import java.util.List;import dao.ProductDAO;public class ProductService &#123; private ProductDAO pdao = new ProductDAO(); //增加商品 public int addProduct(Product p)&#123; return pdao.addProduct(p); &#125; //删除商品 public int deleteProduct(int id)&#123; return pdao.deleteProduct(id); &#125; //更新商品 public int updateProduct(Product p)&#123; return pdao.updateProduct(p); &#125; //列出所有商品 public List&lt;Product&gt; listProduct()&#123; return pdao.listProduct(); &#125; //根据id查找商品 public Product findProductById(int id)&#123; return pdao.findProductById(id); &#125;&#125; servlet 包新建 ListProductServlet 类，调用 ProductService 类中的 listProduct() 方法获取 product list ，并将此传递到 listProduct.jsp 界面，来展示所有商品。ListProductServlet.java 主要代码如下： 123456789101112131415package servlet;@WebServlet("/listProduct")public class ListProductServlet extends HttpServlet&#123; private ProductService ps = new ProductService(); @Override public void service(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException&#123; List&lt;Product&gt; plist = ps.listProduct(); request.setAttribute("plist", plist); //跳转到 listProduct.jsp request.getRequestDispatcher("listProduct.jsp").forward(request, response); &#125;&#125; listProduct.jsp 代码如下（注意编码设置为 utf-8）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;%@ page language="java" contentType="text/html; charset=utf-8" pageEncoding="utf-8"%&gt;&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;table align='center' border='1' cellpadding='4'&gt; &lt;tr &gt; &lt;td&gt;id&lt;/td&gt; &lt;td&gt;name&lt;/td&gt; &lt;td&gt;price&lt;/td&gt; &lt;td colspan='2'&gt;操作&lt;/td&gt; &lt;/tr&gt; &lt;c:forEach items="$&#123;plist&#125;" var="product"&gt; &lt;tr&gt; &lt;td&gt;$&#123;product.id &#125;&lt;/td&gt; &lt;td&gt;$&#123;product.name &#125;&lt;/td&gt; &lt;td&gt;$&#123;product.price &#125;&lt;/td&gt; &lt;td&gt;&lt;a href='deleteProduct?id=$&#123;product.id &#125;'&gt;删除&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href='editProduct?id=$&#123;product.id &#125;'&gt;编辑&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/table&gt; &lt;br&gt;&lt;br&gt; &lt;form action="addProduct" method='post'&gt; &lt;table align='center'&gt; &lt;tr&gt; &lt;td&gt;name&lt;/td&gt; &lt;td&gt;&lt;input type='text' name='name' value='$&#123;product.name &#125;'&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;price&lt;/td&gt; &lt;td&gt;&lt;input type='text' name='price' value='$&#123;product.price &#125;'&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type='submit' value='增加商品' &gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 此界面中，还包含删除商品，编辑商品以及增加商品的链接或者按钮。摘取如下： 123&lt;td&gt;&lt;a href='deleteProduct?id=$&#123;product.id &#125;'&gt;删除&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;a href='editProduct?id=$&#123;product.id &#125;'&gt;编辑&lt;/a&gt;&lt;/td&gt;&lt;form action="addProduct" method='post'&gt; 本项目中，是根据商品 id 来删除商品。 DeleteProductServlet.java 主要代码如下： 123456789101112131415package servlet;@WebServlet("/deleteProduct")public class DeleteProductServlet extends HttpServlet&#123; private ProductService ps = new ProductService(); public void service(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException&#123; ps.deleteProduct(Integer.parseInt(request.getParameter("id"))); //删除后跳转到展示商品的界面 response.sendRedirect("listProduct"); &#125;&#125; listProduct.jsp 中除了展示所有商品，还包含有用于增加商品的表单，以此提交新增商品的信息，表单中action=&quot;addProduct&quot; ，即是 AddProductServlet 的 url-pattern AddProductServlet.java 主要代码如下： 12345678910111213141516171819202122232425package servlet;@WebServlet("/addProduct")public class AddProductServlet extends HttpServlet&#123; private ProductService ps = new ProductService(); public void service(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException&#123; //设置编码 request.setCharacterEncoding("utf-8"); String name = request.getParameter("name"); float price = Float.parseFloat(request.getParameter("price")); Product p = new Product(); p.setName(name); p.setPrice(price); //增加商品 ps.addProduct(p); response.sendRedirect("listProduct"); &#125;&#125; 编辑商品信息：在listProduct.jsp 界面中点击“编辑”链接，把商品 id 传递到 EditProductServlet ，EditProductServlet 根据商品 id 查找对应商品的旧信息，然后把旧的信息传递给editProduct.jsp 界面显示出来。接着，在修改界面修改信息后，提交给SaveProductServlet 。最后，在SaveProductServlet 中，调用ProductService 类中的方法更新商品，再跳转到listProduct.jsp 界面。 EditProductServlet.java 主要代码： 1234567891011121314151617package servlet@WebServlet("/editProduct")public class EditProductServlet extends HttpServlet&#123; private ProductService ps = new ProductService(); public void service(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException&#123; int id = Integer.parseInt(request.getParameter("id")); //根据id查找商品 Product p = ps.findProductById(id); request.setAttribute("product", p); request.getRequestDispatcher("editProduct.jsp").forward(request, response); &#125;&#125; editProduct.jsp 主要代码： 1234567891011121314151617181920&lt;form action="saveProduct" method='post'&gt; &lt;table align='center'&gt; &lt;tr&gt; &lt;td&gt;name&lt;/td&gt; &lt;td&gt;&lt;input type='text' name='name' value='$&#123;product.name &#125;'&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;price&lt;/td&gt; &lt;td&gt;&lt;input type='text' name='price' value='$&#123;product.price &#125;'&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type='submit' value='保存' &gt;&lt;/td&gt; &lt;td&gt;&lt;input type='button' value='返回' onclick="location.href='listProduct'"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type='hidden' name='id' value='$&#123;product.id &#125;'&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/form&gt; SavaProductServlet.java 主要代码： 123456789101112131415161718192021222324@WebServlet("/saveProduct")public class SaveProductServlet extends HttpServlet&#123; private ProductService ps = new ProductService(); public void service(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException&#123; request.setCharacterEncoding("utf-8"); //获取editProduct.jsp提交的参数 int id = Integer.parseInt(request.getParameter("id")); String name = request.getParameter("name"); float price = Float.parseFloat(request.getParameter("price")); Product p = new Product(); p.setId(id); p.setName(name); p.setPrice(price); //更新商品 ps.updateProduct(p); response.sendRedirect("listProduct"); &#125; &#125; 至此，实现商品信息的增删查改相关代码已编写完毕。输入 http://localhost:8080/Management/listProduct 即可查看商品信息。 下一篇文章将写用户的登录注册部分 本文章完整代码见 Github。]]></content>
      <categories>
        <category>java</category>
        <category>java web</category>
      </categories>
      <tags>
        <tag>java web</tag>
        <tag>商品管理系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java web Listener（监听器）]]></title>
    <url>%2F2018%2Fjava-web-Listener%2F</url>
    <content type="text"><![CDATA[Listener 概述Listener（监听器）用于监听 Java Web 程序中的事件，例如创建、修改、删除 session、request、context 等，并触发相应的事件。利用 Listener 能够用很少的代码实现比较好的效果。 Listener 分类分类Servlet 2.5 规范中共有8种 Listener，这8种 Listener 可以分为三类：(1) 监听 session、context、request 等的创建与销毁：HttpSessionListener、ServletContextListener、ServletRequestListener。 HttpSessionListener: void sessionCreated(HttpSessionEvent e) void sessionDestroyed(HttpSessionEvent e) ServletContextListener: void contextInitialized(ServletContextEvent e) void contextDestroy(ServletContextEvent e) ServletRequestListener: void requestInitialized(ServletRequestEvent e) void requestDestroyed(ServletRequestEvent e) (2) 监听 session、context、request 的属性变化：HttpSessionAttributeListener、ServletContextAttributeListener、ServletRequestAttributeListener。 ServletContextAttributeListener: 123void attributeAdded(ServletContextAttributeEvent e)void attributeRemoved(ServletContextAttributeEvent e)void attributeReplaced(ServletContextAttributeEvent e) 其他两个 Listener 里的方法跟这个类似，不多说。 (3) 监听 session 内的对象：HttpSessionBindingListener、HTTPSessionActivationListener HttpSessionBindingListener：当对象被放到 session 里时执行valueBound(HttpSessionBindingEvent event) 方法。当对象被从 session 里移除时执行 valueUnbound(HttpSessionBindingEvent event) 方法。对象必须实现该 Listener 接口。 HttpSessionActivationListener：服务器关闭时，会将 session 里的内容保存到硬盘上，这个过程叫做序列化（钝化）。服务器重新启动时，会将 session 从硬盘重新加载。当 session 里的对象被序列化（钝化）时会执行sessionWillPassivate(HttpSessionEvent event) 方法，当对象被重新加载（反序列化）时执行sessionDidActivate(HttpSessionEvent event) 。对象必须实现该 Listener 接口和 Serializable 接口。 注意：这两种 Listener 不需要在 web.xml 中配置（当然也不需要注解配置）。。 Listener 简单例子1监听session、context、request的创建与销毁： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.anye137.listener;import javax.servlet.*;import javax.servlet.http.*;import javax.servlet.annotation.WebListener;;@WebListenerpublic class ListenerTest implements HttpSessionListener, ServletContextListener, ServletRequestListener&#123; @Override public void contextInitialized(ServletContextEvent e) &#123; //加载servlet上下文时被调用 ServletContext context = e.getServletContext(); System.out.println("启动context："+context.getContextPath()); &#125; @Override public void contextDestroyed(ServletContextEvent e) &#123; ServletContext context = e.getServletContext(); System.out.println("关闭context："+context.getContextPath()); &#125; @Override public void sessionCreated(HttpSessionEvent e) &#123; //创建session时被调用 HttpSession session = e.getSession(); System.out.println("创建session，id为："+session.getId()); &#125; @Override public void sessionDestroyed(HttpSessionEvent e) &#123; //销毁session前被调用 HttpSession session = e.getSession(); System.out.println("销毁session，id为："+session.getId()); &#125; @Override public void requestInitialized(ServletRequestEvent e) &#123; //创建requests时调用 HttpServletRequest request = (HttpServletRequest)e.getServletRequest(); String uri = request.getRequestURI(); uri = uri+"?"+request.getQueryString(); request.setAttribute("dateCreated", System.currentTimeMillis()); System.out.println("IP "+request.getRemoteAddr()+" 请求 "+uri); &#125; @Override public void requestDestroyed(ServletRequestEvent e) &#123; //销毁request时被调用 HttpServletRequest request = (HttpServletRequest)e.getServletRequest(); long time = System.currentTimeMillis()-(Long)request.getAttribute("dateCreated"); System.out.println("IP "+request.getRemoteAddr()+"请求处理结束，用时"+time+"毫秒"); &#125;&#125; 这个例子中的 Listener 是用注解配置的，如果用 web.xml 配置，需要添加一下代码： 123&lt;listener&gt; &lt;listener-class&gt;com.anye137.listener.ListenerTest&lt;/listener-class&gt;&lt;/listener&gt; Listener 简单例子2监听 session 属性变化（监听context、request与监听session类似） 1234567891011121314151617181920212223242526272829303132package com.anye137.listener;import javax.servlet.annotation.WebListener;import javax.servlet.http.HttpSession;import javax.servlet.http.HttpSessionAttributeListener;import javax.servlet.http.HttpSessionBindingEvent;@WebListenerpublic class SessionAttributeListenerTest implements HttpSessionAttributeListener&#123; public void attributeAdded(HttpSessionBindingEvent e) &#123; //添加属性时被调用 HttpSession session = e.getSession(); String name = e.getName(); System.out.println("新建session属性："+name+"，值为："+e.getValue()); &#125; public void attributeRemoved(HttpSessionBindingEvent e) &#123; //删除属性前被调用 HttpSession session = e.getSession(); String name = e.getName(); System.out.println("删除session属性："+name+"，值为"+e.getValue()); &#125; public void attributeReplaced(HttpSessionBindingEvent e) &#123; //修改属性时被调用 HttpSession session = e.getSession(); String name = e.getName(); Object oldValue = e.getValue(); System.out.println("修改session属性："+name+"，原值："+oldValue+",新值："+session.getAttribute(name)); &#125; &#125; Listener 使用案例1.单态登录单态登录，就是一个账号只能在一台机器上登录，如果在其他机器上登录了，则原来的登录自动失效。这样可以防止多台机器同时使用同一个账号。 LoginSessionListener.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.anye137.listener;import java.util.HashMap;import javax.servlet.annotation.WebListener;import javax.servlet.http.*;@WebListenerpublic class LoginSessionListener implements HttpSessionAttributeListener &#123; //储存目前登录的用户,key为userName,value为session HashMap&lt;String, HttpSession&gt; map = new HashMap&lt;&gt;(); @Override //添加session属性时被调用 public void attributeAdded(HttpSessionBindingEvent e)&#123; //新添加的属性 String attrName = e.getName(); if(attrName.equals("userName"))&#123; String attrValue = (String)e.getValue(); //若map中存在该用户 if(map.get(attrValue)!=null)&#123; //将以前的登录失效 HttpSession session = map.get(attrValue); session.removeAttribute("userName"); &#125; //新用户session存进map map.put(attrValue, e.getSession()); System.out.println("账号:"+attrValue+",登录"); &#125; &#125; @Override //删除属性前被调用 public void attributeRemoved(HttpSessionBindingEvent e)&#123; //被删除的属性 String attrName = e.getName(); if(attrName.equals("userName"))&#123; String attrValue = (String) e.getValue(); map.remove(attrValue); System.out.println("账号："+attrValue+",注销"); &#125; &#125; @Override //修改属性时被调用 public void attributeReplaced(HttpSessionBindingEvent e)&#123; String attrName = e.getName(); //没有注销的情况下，用另一个账号登录 if(attrName.equals("userName"))&#123; String oldValue = (String) e.getValue(); String newValue = (String) e.getSession().getAttribute("userName"); //注意要判断新值旧值是否相等 if(!oldValue.equals(newValue))&#123; //检查新登录的账号是否在别的机器上登录过 if(map.get(newValue)!=null)&#123; HttpSession session = map.get(oldValue); session.removeAttribute("userName"); map.remove(oldValue); &#125; map.put(newValue, e.getSession()); System.out.println("原账号："+oldValue+"。被新账号："+newValue+"替代"); &#125; else&#123; System.out.println("账号："+oldValue+",重新登录"); &#125; &#125; &#125; &#125; 登录界面和处理登录的 servlet 跟前面我写过的文章里，登录验证 Filter 里的代码一样，登录后的界面则增加了每隔5s自动刷新以及推出登录的代码 登录界面login.jsp 1234567891011121314&lt;%@ page language="java" contentType="text/html; charset=utf-8" pageEncoding="utf-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action="$&#123;pageContext.request.contextPath&#125;/loginServlet" method="post"&gt; 姓名：&lt;input type="text" name="userName"/&gt;&lt;br&gt; &lt;input type="submit" value="登录"/&gt;&lt;br&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 处理登录的servlet loginServlet.java 12345678910111213141516171819202122package com.anye137.test;import java.io.IOException; import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.*; @WebServlet("/loginServlet")public class LoginServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; HttpSession session = request.getSession(); session.setAttribute("userName", request.getParameter("userName")); response.sendRedirect("jsp/afterLogin.jsp"); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125; &#125; 登录后的界面afterLogin.jsp 12345678910111213141516171819202122232425262728&lt;%@ page language="java" contentType="text/html; charset=utf-8" pageEncoding="utf-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;% if(request!=null)&#123; String action = request.getParameter("action"); if("logout".equals(action))&#123; out.println("jjj"); session.removeAttribute("userName"); response.sendRedirect(request.getContextPath()+"/jsp/login.jsp"); &#125; &#125;%&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type="text/javascript"&gt; &lt;!-- 每5秒刷新一次 --&gt; setTimeout("location=location; ", 5000); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; 用户名： &lt;%= session.getAttribute("userName") %&gt; 您已成功登陆 &lt;br&gt; &lt;a href="$&#123;pageContext.request.requestURI&#125;?action=logout"&gt;退出&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; 本例中，Listener 用 map 储存已登录的用户名及对应 session，并监听 session 中 userName 属性的变化，作出相应的处理来实现单态登录。 在实际应用中，我们也可以使用类 User 来储存用户更详细的信息，比如 ip 地址，登录时间等，这时 session 存储的属性值应该是 User 类对象。 本文章完整代码见 Github。 参考资料(1) 《JavaWeb王者归来》]]></content>
      <categories>
        <category>java</category>
        <category>java web</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java web</tag>
        <tag>Listener</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java web Filter（过滤器）下]]></title>
    <url>%2F2018%2Fjava-web-filter-2%2F</url>
    <content type="text"><![CDATA[Filter 常用例子3. 登录验证 Filter我们在浏览网站的时候，有时候是没有登录的，或者因为登录很久后自动掉出来。可能有一些请求需要判断用户是否处于登录状态 ，以及该用户的权限。Java Web 程序一般使用 session 或者 cookie 来记录用户是否登录。登录验证 Filter 是将 request 提交给 servlet 之前，对 session 或者 cookie 进行校验。如果没有相应的登录信息，或者权限不够，则进行相应的处理，比如跳转到登录界面。 下面的例子中，我们仅判断用户是否处于登录状态。 PrivilegeFilter.java 1234567891011121314151617181920212223242526package com.anye137.filter;import java.io.IOException;import javax.servlet.*;import javax.servlet.annotation.WebFilter;import javax.servlet.http.*;@WebFilter(filterName="privilegeFilter",urlPatterns="/jsp/afterLogin.jsp")public class PrivilegeFilter implements Filter&#123; public void init(FilterConfig config) throws ServletException&#123;&#125; public void destroy()&#123;&#125; public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException&#123; HttpServletRequest req = (HttpServletRequest)request; HttpServletResponse res = (HttpServletResponse)response; HttpSession session = req.getSession(); String name = (String) session.getAttribute("userName"); if(name==null || name.trim().equals("")) res.sendRedirect(req.getContextPath()+"/jsp/login.jsp"); else chain.doFilter(req, response); &#125; &#125; 登录界面 login.jsp 123456789101112131415&lt;%@ page language="java" contentType="text/html; charset=utf-8" pageEncoding="utf-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action="$&#123;pageContext.request.contextPath&#125;/loginServlet" method="post"&gt; 姓名：&lt;input type="text" name="name"/&gt;&lt;br&gt; &lt;input type="submit" value="登录"/&gt;&lt;br&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 处理登录的 servlet LoginServlet.java 1234567891011121314151617181920212223package com.anye137.test;import java.io.IOException; import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.*; @WebServlet("/loginServlet")public class LoginServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; HttpSession session = request.getSession(); session.setAttribute("userName", request.getParameter("userName")); response.sendRedirect("jsp/afterLogin.jsp"); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125; &#125; 登录后的界面afterLogin.jsp 123456789101112&lt;%@ page language="java" contentType="text/html; charset=utf-8" pageEncoding="utf-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 用户名： &lt;%= session.getAttribute("name") %&gt; 您已成功登陆 &lt;/body&gt;&lt;/html&gt; 运行效果：通过login.jsp 页面可以登录进入 afterLogin.jsp 页面，如果没有登录直接输入afterLogin.jsp 的网址，则会跳转到登录界面。 注意，上面代码中并没有设置 request 和 response 编码，因为我在上一篇文章中已经写好了 CharacterEncodingFilter 。当然，如果不想用字符编码 Filter，我们也可以在 servlet 中简单设置下编码。 4.内容替换 Filter有时候需要对网站的内容进行控制，防止输出非法内容或者敏感内容。常规的解决办法是在保存进数据库之前对非法敏感内容进行替环，或者在 servlet 里输出到客户端时进行替环。这两种解决方案都有很大的局限性，例如每个 servlet 都要进行替换、工作量大，与业务耦合比较严重等。 使用内容替换 Filter 则方便得多，其工作原理是：在 servlet 内将内容输出到 response 时，response 将内容缓存起来，在 Filter 中进行替换，然后再输出到客户端浏览器。由于默认的 response 并不能严格地缓存输出内容，因此需要自定义一个具备缓存功能的 response。 OutputReplaceFilter.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.anye137.filter;import java.io.*;import java.util.Properties;import javax.servlet.*;import javax.servlet.annotation.WebFilter;import javax.servlet.annotation.WebInitParam;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpServletResponseWrapper;@WebFilter( filterName="outputReplaceFilter", urlPatterns="/*", initParams=&#123;@WebInitParam(name="file",value="/WEB-INF/sensitive.properties")&#125; )public class OutputReplaceFilter implements Filter &#123; //非法词、敏感词配置在 properties文件中 private Properties pp = new Properties(); public OutputReplaceFilter() &#123;&#125; public void init(FilterConfig config) throws ServletException &#123; //properties文件名 String file = config.getInitParameter("file"); //文件位置 String realPath = config.getServletContext().getRealPath(file); try&#123; //如果properties文件是ISO-8859-1编码，可以直接用这句：pp.load(new FileInputStream(realPath)); //如果文件是utf-8编码，且包含中文，需用下面两句 BufferedInputStream in = new BufferedInputStream(new FileInputStream(realPath)); pp.load(new InputStreamReader(in, "utf-8")); &#125;catch(IOException e)&#123;&#125; &#125; public void destroy() &#123;&#125; public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; System.out.println("replace"); HttpServletResponse res = (HttpServletResponse)response; //使用自定义response OutputReplaceResponse orr = new OutputReplaceResponse(res); //doFilter，使用自定义 response orr chain.doFilter(request, orr); //得到response输出内容 String output = orr.getCharArrayWriter().toString(); //遍历所有敏感词 for(Object obj: pp.keySet())&#123; String key = (String)obj; //替换敏感词 output = output.replace(key, pp.getProperty(key)); &#125; //通过原来的response的getWriter()方法输出 PrintWriter out = response.getWriter(); //真正输出到客户端 out.write(output); &#125; //自定义response类 class OutputReplaceResponse extends HttpServletResponseWrapper&#123; //字符数组Writer &#125; &#125; 自定义的response 类OutputReplaceResponse 1234567891011121314151617class OutputReplaceResponse extends HttpServletResponseWrapper&#123; //字符数组Writer private CharArrayWriter caw=new CharArrayWriter(); public OutputReplaceResponse(HttpServletResponse response) &#123; super(response); &#125; @Override public PrintWriter getWriter() throws IOException&#123; //返回字符数组Writer，缓存内容 return new PrintWriter(caw); &#125; public CharArrayWriter getCharArrayWriter()&#123; return caw; &#125; &#125; 本例中，自定义的 response 只是一个“伪装”的 response。servlet会通过它输出内容到客户端，但是它内部只是将内容缓存起来了，并没有真正输出到客户端。最终输出到客户端还是通过原来的 response 完成的。 词库配置 sensitive.properties 123456# 自动更正Chna = China# 自动替换赌博 = **色情 = **情色 = ** 我把 properties 文件设置为 utf-8 编码的 （eclipse中右键文件名，点Properties 设置就行了），在上面的 Filter 中是这样加载的： 12BufferedInputStream in = new BufferedInputStream(new FileInputStream(realPath)); pp.load(new InputStreamReader(in, "utf-8")); 使用 utf-8 编码的话，在 properties 文件中直接输入中文会正常显示。如果把文件编码设置为 ISO-8859-1，这时在编辑器输入中文，只能显示出中文对应的 Unicode 编码，但是对后续的操作其实影响不大。加载此文件只需一行代码： 1pp.load(new FileInputStream(realPath)); 测试页面testReplace.jsp 1234567891011121314&lt;%@ page language="java" contentType="text/html; charset=UTF-8" %&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; Chna &lt;br/&gt; &lt;br/&gt; 色情 &lt;br/&gt; 赌博 &lt;br/&gt; 情色 &lt;br/&gt; &lt;/body&gt;&lt;/html&gt; 在浏览器中输入测试页面网址，可以看到替换后的效果。 上面 Filter 是在init() 方法中加载 properties 文件的，Filter inti() 方法只在 web 程序第一次运行时调用一次。所以如果词库更新的话，需要重启 web 程序。 Filter 还有许多常用例子，例如缓存Filter、GZIP压缩Filter等，这里就不一一详述了。 本文详细代码见 Github 参考资料(1) 《JavaWeb 王者归来》(2) Java读写.properties文件实例，解决中文乱码问题 from CSDN]]></content>
      <categories>
        <category>java</category>
        <category>java web</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java web</tag>
        <tag>Filter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java web Filter（过滤器）上]]></title>
    <url>%2F2018%2Fjava-web-filter-1%2F</url>
    <content type="text"><![CDATA[Filter 概述Filter（过滤器）用于在 servlet 之外对 request 或者 response 进行拦截、修改，甚至可以拒绝、重定向或者转发 request。Filter 提出了 FilterChain 的概念，一个 FilterChain 包括多个 Filter。客户端请求 request 在抵达 servlet 之前会经过 FilterChain 里的所有 Filter，服务器响应 response 在从 servlet 抵达客户端浏览器之前也会经过 FilterChain 里的所有Filter。Filter处理过程如图所示： Filter 接口一个 Filter 必须实现 javax.servlet.Filter 接口。Filter 接口有三个方法，源代码如下： 123456789101112131415161718192021222324252627//Filter.javapackage javax.servlet;import java.io.IOException;public interface Filter&#123; /** * web程序启动时调用此方法，用于初始化该Filter * @param config 可以从该参数中获取初始化参数以及ServletContext信息等 * @throws ServletException */ public void init(FilterConfig config) throws ServletException; /** * 客户端请求服务器时会经过 * @param request 请求 * @param response 响应 * @param chain * @throws ServletException * @throws IOException */ public void doFilter(ServletRequest request,ServletResponse response, FilterChain chain) throws ServletException, IOException; /** * web程序关闭时调用此方法，用于销毁一些资源 */ public void destroy();&#125; 其中，init() 与destroy() 方法只会分别在 web 程序加载和卸载的时候调用。而doFilter() 方法每次有客户端请求时都会被调用一次。 一个简单的doFilter() 方法例子 1234567public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException&#123; System.out.println("request 被处理之前... "); //一定要执行这句 chain.doFilter(request, response); System.out.println("request 被处理之后，response 抵达客户端之前... ");&#125; 其中chain.doFilter(request, response) 将 request 递交给 FilterChain 中的下一个 Filter，如果所有的 Filter 都执行完了则交给 servlet 处理。 Filter 配置在 web.xml 中配置一个例子 1234567891011121314151617&lt;filter&gt; &lt;filter-name&gt;filterName&lt;/filter-name&gt; &lt;filter-class&gt;com.anye137.SomeFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;paramName&lt;/param-name&gt; &lt;param-value&gt;paramValue&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;filterName&lt;/filter-name&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;servlet-name&gt;someServlet&lt;/servlet-name&gt; &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt; &lt;dispatcher&gt;FORWARD&lt;/dispatcher&gt;&lt;/filter-mapping&gt; 一个 Filter 需要配置&lt;filter&gt; 和&lt;filter-mapping&gt; 标签 &lt;filter&gt; 标签需要配置&lt;filter-name&gt; 和&lt;filter-class&gt; 以及0或多个&lt;init-param&gt; （初始化参数） &lt;filter-mapping&gt; 配置 Filter 的拦截规则 &lt;url-pattern&gt; 配置 URL 映射，可以配置多个。在上面的例子中，如果一个请求访问的 URL 结尾是 .do 或者是 .jsp，就可以匹配此 Filter。通过使用&lt;url-pattern&gt; ，我们不仅可以拦截 servlet 的请求，还可以拦截其他资源，例如图片、css 文件等 &lt;servlet-name&gt; 配置 servlet 名称映射，即对应的 servlet 会被Filter 拦截，可以配置多个。有时候，许多 URL 会映射到同一个 servlet，这时候使用&lt;servlet-name&gt; 相较于&lt;url-pattern&gt; 比较方便 &lt;dispatcher&gt; 配置派发请求的方式，可以配置多个。如果没有配置任何dispatcher，则默认为 REQUEST。&lt;dispatcher&gt; 取值有： REQUEST：直接请求，例如直接访问 URL。 FORWARD：当调用RequestDispatcher 的forward 方法或者使用&lt;jsp: forward&gt; 标签时，将触发这些请求 INCLUDE：当调用RequestDispatcher 的include 方法或者使用&lt;jsp: include&gt; 标签时，将触发这些请求（记住它与&lt;%@ include %&gt; 是不同的） ERROR：访问处理 http 错误（如404 Not Found等）的错误页面的请求 ASYNC：（这个我也不太懂，不多说。。。） 一个 web 程序可以配置多个 Filter，如何比较两个Filter 执行顺序：(1) 首先，URL 映射优先级高于 servlet 名称映射，不管其在 web.xml 中配置的顺序如何(2) 其次，如果同为 URL 映射或者同为 servlet 名称映射，则比较&lt;servlet-mapping&gt; 在 web.xml 中出现的顺序 使用注解配置Filter 也可以使用注解配置，下面配置跟上面是等价的 12345678910111213import javax.servlet.annotation.WebFilter;@WebFilter( filterName = "myFilter", urlPattern = &#123;"*.do", "*.jsp"&#125;, servletName = &#123;"someServlet"&#125;, dispatcherTypes = &#123;DispatcherType.REQUEST, DispatcherType.FORWARD&#125; initParams = &#123; @WebInitParam(name = "paramName", value = "paramValue") &#125;)public class SomeFilter implements Filter&#123; //......&#125; 使用注解配置的主要缺点是，不能对 FilterChain 上的 Filter 进行排序。 Filter 常用例子我们可以通过在doFilter() 方法内编写代码，达到以下目的：(1) 通过控制是否调用 chain.doFilter() ，来决定是否访问目标资源。例如：防盗链 Filter、权限验证 Filter。(2) 调用 chain.doFilter() 之前，做某些处理。例如：字符编码 Filter。(3) 调用 chain.dpFilter() 之后，做某些处理。例如：内容替换 Filter，GZIP压缩 Filter（当然，我们也可以综合使用上面三种方式） 下面介绍下一些例子。 1. 防盗链 Filter实现效果：如果其他的网站引用本网站的图片等资源，将会显示一个错误图片，只有本站内的网页引用时，图片才会正常显示。 123456789101112131415161718192021222324252627package com.anye137.filter;import java.io.IOException;import javax.servlet.*;import javax.servlet.http.*;public class AntiStealingLinkFilter implements Filter &#123; public AntiStealingLinkFilter() &#123;&#125; public void init(FilterConfig fConfig) throws ServletException &#123;&#125; public void destroy() &#123;&#125; public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; HttpServletRequest req=(HttpServletRequest)request; //请求来源网址 String referer=req.getHeader("referer"); //如果请求不是来自本站 if(referer==null||!referer.contains(req.getServerName()))&#123; req.getRequestDispatcher("/error.jpg").forward(req, response); &#125; else&#123; //如果来自本站 chain.doFilter(req, response); &#125; &#125;&#125; doFilter() 方法中，首先要将 request 转为 HttpServletRequest 类的对象 req。只有这样，才能使用一些针对 http 协议的方法，例如 String getMethod() 、String getHeader(String name) 、HttpSession getSession() 等。 在 web.xml 中配置如下： 123456789&lt;filter&gt; &lt;filter-name&gt;antiStealingLinkFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.anye137.filter.AntiStealingLinkFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;antiStealingLinkFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/images/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 在此配置下，从别的网站请求 WebContent/images 文件夹下的资源，或者直接输入资源 URL 就只会显示我们之前在 Filter 类中设置好的 error.jpg。本站访问，则正常显示。 2.字符编码 Filter字符编码 Filter 是最常用的 Filter 之一，常用来解决 Tomcat 等服务器里 request，response 乱码的问题。本例中我们使用 Filter 来解决全站中文乱码问题。 对 response 的设置：12response.setCharacterEncoding("utf-8");response.setContentType("text/html;charset=utf-8"); 其中，setCharacterEncoding 用于解决response.getWriter() 输出字符流的乱码问题，其作用是将 response 中的数据解码后发向浏览器。setContentType 用于设置浏览器用我们指定的方式解码，然后呈现出来。 对 request 的设置：(1) 若是 POST 方式，直接设置1request.setCharacterEncoding("utf-8"); ` (2) 若是 GET 方式，12paramValue = request.getParameter(paramName)paramValue = new String(paramValue.getBytes("ISO8859-1"),"utf-8"); 如果对每个 Servlet 都编写上面的代码，则会显得冗赘。使用 Filter 只需一次编写，就能解决全站编码问题。同时，为了实现对 POST 和 GET 方式的分开处理，我们后面实现了自定义的 Request 类：EncodingRequest.java Filter 代码： CharacterEncodingFilter.java 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.anye137.filter;import java.io.*;import javax.servlet.*;import javax.servlet.http.*;public class CharacterEncodingFilter implements Filter &#123; //是否启用该Filter private boolean enabled; @Override public void init(FilterConfig config) throws ServletException &#123; // 初始化时从 web.xml中加载参数 enabled = config.getInitParameter("enabled").trim().equalsIgnoreCase("true"); &#125; @Override public void destroy() &#123;&#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; //如果启用了Filter if(enabled)&#123; //设置response编码 response.setCharacterEncoding("utf-8"); response.setContentType("text/html;charset=utf-8"); //设置request编码 HttpServletRequest req=(HttpServletRequest)request; EncodingRequest er=new EncodingRequest(req); chain.doFilter(er, response); &#125; else chain.doFilter(request, response); &#125; //内部类 class EncodingRequest extends HttpServletRequestWrapper&#123; //代码 &#125;&#125; 在CharacterEncodingFilter 类中，先获取初始化参数enabled 判断是否开启该 Filter，如果开启，则先设置 response 编码，然后设置 request 编码。我们使用自定义的EncodingRequest 内部类来实现对request 字符编码的设置（注意区分 GET 和 POST 处理方式的不同）。 内部类EncodingRequest 代码如下： 1234567891011121314151617181920212223242526272829303132public class EncodingRequest extends HttpServletRequestWrapper&#123; private HttpServletRequest req; public EncodingRequest(HttpServletRequest request)&#123; super(request); this.req = request; if(req.getMethod().equalsIgnoreCase("POST"))&#123; try &#123; req.setCharacterEncoding("utf-8"); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; &#125; &#125; @Override public String getParameter(String name)&#123; String value = null; if(req!=null)&#123; value = req.getParameter(name); if(req.getMethod().equalsIgnoreCase("GET"))&#123; value = req.getParameter(name); if(value!=null)&#123; try&#123; value = new String(value.getBytes("ISO-8859-1"),"utf-8"); &#125;catch(UnsupportedEncodingException e)&#123; e.printStackTrace(); &#125; &#125; &#125; &#125; return value; &#125;&#125; Filter 在 web.xml 中配置如下： 12345678910111213&lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.anye137.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;enabled&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 测试页面 testEncoding.jsp : 123456789101112131415161718192021&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;post提交&lt;/h1&gt; &lt;form action="$&#123;pageContext.request.contextPath &#125;/testEncoding" method="post"&gt; 姓名：&lt;input type="text" name="name"/&gt;&lt;br&gt; &lt;input type="submit" value="提交"/&gt;&lt;br&gt; &lt;/form&gt; &lt;h1&gt;get提交&lt;/h1&gt; &lt;form action="$&#123;pageContext.request.contextPath &#125;/testEncoding" method="get"&gt; 姓名：&lt;input type="text" name="name"/&gt;&lt;br&gt; &lt;input type="submit" value="提交"/&gt;&lt;br&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 处理提交参数的 testEncoding.java : 123456789101112131415161718192021package com.anye137.test;import java.io.IOException; import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.*; @WebServlet("/testEncoding")public class TestEncoding extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //输出信息，测试是否乱码 response.getWriter().write("Hello, 测试乱码！输入姓名为： "+request.getParameter("name")); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125; &#125; 输入testEncoding.jsp 所在网址，填写信息提交后，将由 TestEncoding servlet 来处理提交的信息。该 servlet 会输出一条信息，以此判断是否乱码。至此，我们已经完成了 CharacterEncodingFilter 的编写及测试。 根据从网上查阅的资料，对 POST 方式和 GET 方式的编码处理是不一样的，我上面的代码也是这样。然而，我在测试的时候发现，把 GET 方式的编码处理方法应用于 POST 方式，也是行得通的，这样代码更简洁点。所以，为什么网上的资料是分开处理的呢？处理字符编码的代码的原理又是啥？这个以后有时间研究下。 总结Filter（过滤器）是一个很有弹性的机制，功能很强大，而且与servlet、jsp等没有任何的耦合，可自由拆卸。如果配置了多个 Filter，则执行会有先有后，彼此之间还可能会相互影响，要注意正确配置 Filter 的顺序。 下篇博客将继续写 Filter 使用案例。 本文章完整代码见 Github。 参考资料(1) 《Java Web 王者归来》(2) 《Java Web 高级编程》(3) servlet Filter from CSDN(4) Servlet 中文乱码问题及解决方案剖析 from CSDN(5) 解决全站字符乱码问题 from GitHub]]></content>
      <categories>
        <category>java</category>
        <category>java web</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java web</tag>
        <tag>Filter</tag>
        <tag>防盗链</tag>
        <tag>字符编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合框架常用知识点总结]]></title>
    <url>%2F2018%2Fjava-Collections-Map%2F</url>
    <content type="text"><![CDATA[ArrayList1234567891011121314151617181920212223242526272829303132333435363738394041ArrayList&lt;String&gt; a=new ArrayList&lt;String&gt;();//add()函数a.add("a"); //[a]a.add("b"); //[a, b]a.add("c"); //[a, b, c]a.add(1, "d"); //[a, d, b, c]//contains()boolean b=a.contains("f"); //false //get()String s1=a.get(1); //dString s2=a.get(5); //运行时抛出IndexOutOfBoundsException//indexOf()int i=a.indexOf("a"); //0//remove()a.remove("a"); //[d, b, c]a.remove(1); //[d, c]//set()a.set(1,"aaa"); //[d, aaa]//size()int si=a.size(); //2 //addAll() ArrayList&lt;String&gt; a1=new ArrayList&lt;String&gt;();a1.add("e");a1.add("f");a.addAll(a1); //[d, aaa, e, f] //clear()a.clear(); //[]//遍历for(String s:a)&#123; System.out.println(s);&#125; LinkedList基本上ArrayList函数都适用于LinkedList。LinkedList还可以使用如下函数： 12345678void addFirst(Object element)void addLast(Object element)Object getFirst()Object getLast()Object removeFirst()Object removeLast() Queue1234567891011//Queue代表FIFO 先进先出的队列Queue&lt;String&gt; q= new LinkedList&lt;String&gt;(); //offer() 加在队列的最后面q.offer("aa"); //poll() 取出并返回第一个。如果队列为空，返回nullString s1 = q.poll();//peek() 查看第一个，但是不取出来。如果队列为空，返回nullString s2 = q.peek() Stack1234567891011//查看stack顶部的元素Object peek( ) //取出并返回stack顶部元素Object pop( )//加在stack顶部Object push(Object element)//判断stack是否为空boolean empty() HashMap1234567891011121314151617HashMap&lt;String,String&gt; m = new HashMap&lt;&gt;();m.put("name", "Tony");m.put("address", "Guangzhou"); Object get(Object key) Object remove(Object key)void clear( )int size( )//遍历mapfor (Map.Entry&lt;String, String&gt; entry : m.entrySet()) &#123; System.out.println("key= " + entry.getKey() + " and value= " + entry.getValue());&#125; Collections常用函数1234567891011List&lt;Integer&gt; numbers = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; numbers.add(i);&#125; Collections.reverse(numbers);Collections.sort(numbers);Collections.swap(numbers,0,5); Comparator12345678910111213141516171819202122232425262728293031323334public class Student&#123; public int score1; public int score2;&#125;List&lt;Person&gt; slist = new ArrayList&lt;&gt;();//直接使用Collections.sort(slist)会编译出错//需引入Comparator，指定比较的算法, 这里按score1由低到高排序Comparator&lt;Student&gt; comp = new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student s1, Student s2) &#123; //按照score1进行排序 if(s1.score1&gt;=s2.score1) return 1; //正数表示h1比h2要大 else return -1; &#125;&#125;;Collections.sort(slist, comp);//或者Student类实现Comparable接口，在类里面提供比较的算法public class Student implements Comparable&lt;Student&gt;&#123; public int score1; public int score2; @Override public int compareTo(Hero h)&#123; if(score1&gt;=h.score1) return 1; else return -1; &#125;&#125;Collections.sort(slist);]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>集合框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用hexo搭建博客]]></title>
    <url>%2F2018%2Fhexo-blog%2F</url>
    <content type="text"><![CDATA[​ - 搭建博客使用hexo+github搭建个人博客，具体操作见参考网址http://mp.weixin.qq.com/s/rMZZkHbMeKXsSAvAdsgyRw 修改主题这里我用的是next主题，GitHub地址https://github.com/iissnan/hexo-theme-next在站点目录打开git bash，输入 1$ git clone https://github.com/iissnan/hexo-theme-next themes/next 将next主题下载到站点目录的themes/next文件夹中。打开站点的_config.yml配置文件，修改主题为next1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next next主题有好几种样式。打开主题中的_config.yml文件，进行设置12345678# ---------------------------------------------------------------# Scheme Settings# ---------------------------------------------------------------# Schemes#scheme: Muse#scheme: Mist#scheme: Piscesscheme: Gemini 最后在站点目录下打开git bash，输入123$ hexo clean$ hexo g$ hexo d 到此，主题修改完毕。其他一些配置，诸如修改作者昵称、头像、网页标题、图标、博客语言，以及增加标签页面和分类页面，设置主页底部的站点建立时间等 可参考next主题的GitHub 以及 NexT使用文档 添加本地搜索功能参考网址http://hisen.me/20170407-Hexo%20next%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%9C%AC%E5%9C%B0%E6%90%9C%E7%B4%A2%20-%20%E4%B8%8D%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E6%9C%8D%E5%8A%A1/ 内容摘录如下： 安装插件在站点根目录打开git bash，输入以下内容，安装 hexo-generator-search 和 hexo-generator-searchdb12$ npm install hexo-generator-search --save$ npm install hexo-generator-searchdb --save 启用搜索编辑站点文件_config.yml，添加以下内容开启搜索12345search: path: search.xml field: post format: html limit: 10000 编辑主题文件_config.yml，启用本地搜索功能：123# Local searchlocal_search: enable: true 最后重新生成和部署站点就行了 发布新文章新建文章站点目录下，输入 1$ hexo n "blog_name" 然后站点目录下source/_post文件夹中多了一个 blog_name.md 文件，此文件的内容即是博客的内容。我们可以使用编辑器编辑此文件。个人推荐的编辑器是Topyra 或 Cmd Markdown 添加标签和分类blog_name.md文件开头是这样的 12345---title: 用hexo搭建博客date: 2018-01-31 17:46:57tags: --- 添加标签和分类，如下： 123456---title: 用hexo搭建博客date: 2018-01-31 17:46:57tags: [hexo]categories: hexo--- 多个标签可用逗号隔开 若要创建多级分类，则 123categories: - 一级分类 - 二级分类 要想新建博客时默认带上tags: [] 和 categories: 打开站点目录下 scaffolds/post.md 文件，默认内容如下： 12345---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags:--- 修改成 123456---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags: []categories:--- 设置阅读全文默认情况下，站点首页会显示最新的文章的全部内容，我们可以设置成只显示文章的一部分，然后在后面提供一个链接阅读全文来进入文章的详情页。 在文章中合适的位置添加 &lt; !--more--&gt; 标签，这样只有标签前的内容会在首页中显示 预览和发布博客预览保存博客md文件，进入站点目录，打开git bash，输入 1$ hexo s --debug 浏览器输入 http://localhost:4000 即可预览 发布在站点目录下，打开git bash，输入 123$ hexo clean$ hexo g$ hexo d 即可将博客内容部署到GitHub 后记至此，hexo搭建博客基本完成啦O(∩_∩)O 其实我之前用过WordPress搭建过博客，然而写了十篇左右就没怎么写了，后来那个站点也弃了，改用有道云笔记记录自己平时的学习笔记。希望以后在做好有道云笔记的同时，也多写写博客！]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2Fhexo-hello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
